<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BIP39 Mnemonic Tools</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .tools-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .tool-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .tool-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
        }

        .tool-card h2 {
            color: #5a67d8;
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #4a5568;
        }

        .form-control {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .form-control:focus {
            outline: none;
            border-color: #5a67d8;
            box-shadow: 0 0 0 3px rgba(90, 103, 216, 0.1);
        }

        .btn {
            background: linear-gradient(135deg, #5a67d8, #667eea);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(90, 103, 216, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #718096, #a0aec0);
        }

        .result-area {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            min-height: 100px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            white-space: pre-wrap;
            overflow-x: auto;
        }

        .mnemonic-display {
            background: #edf2f7;
            border-left: 4px solid #5a67d8;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }

        .mnemonic-words {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }

        .mnemonic-word {
            background: white;
            padding: 8px 12px;
            border-radius: 6px;
            text-align: center;
            font-weight: 500;
            border: 1px solid #cbd5e0;
        }

        .status {
            padding: 10px 15px;
            border-radius: 6px;
            margin: 10px 0;
            font-weight: 500;
        }

        .status.success {
            background: #c6f6d5;
            color: #22543d;
            border: 1px solid #9ae6b4;
        }

        .status.error {
            background: #fed7d7;
            color: #742a2a;
            border: 1px solid #fc8181;
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #e2e8f0;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .tab.active {
            border-bottom-color: #5a67d8;
            color: #5a67d8;
            font-weight: 600;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .bit-pattern-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .pattern-card {
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .pattern-header {
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 8px;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #5a67d8;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .tools-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .mnemonic-words {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîê BIP39 Mnemonic Tools</h1>
            <p>Generate, validate, and analyze Bitcoin mnemonic phrases</p>
        </div>

        <div class="tools-grid">
            <!-- Generator Tool -->
            <div class="tool-card">
                <h2>üé≤ Mnemonic Generator</h2>
                
                <div class="tabs">
                    <div class="tab active" onclick="switchTab('gen', 'random')">Random</div>
                    <div class="tab" onclick="switchTab('gen', 'hex')">Hex</div>
                    <div class="tab" onclick="switchTab('gen', 'binary')">Binary</div>
                </div>

                <div id="gen-random" class="tab-content active">
                    <p>Generate a cryptographically secure random mnemonic phrase.</p>
                    <button class="btn" onclick="generateMnemonic('random')">Generate Random Mnemonic</button>
                </div>

                <div id="gen-hex" class="tab-content">
                    <div class="form-group">
                        <label for="hex-input">128-bit Entropy (32 hex characters):</label>
                        <input type="text" id="hex-input" class="form-control" placeholder="e.g., a1b2c3d4e5f6789012345678901234ab" maxlength="32">
                    </div>
                    <button class="btn" onclick="generateMnemonic('hex')">Generate from Hex</button>
                </div>

                <div id="gen-binary" class="tab-content">
                    <div class="form-group">
                        <label for="binary-input">128-bit Entropy (128 binary digits):</label>
                        <textarea id="binary-input" class="form-control" placeholder="128 binary digits (0s and 1s)" rows="4"></textarea>
                    </div>
                    <button class="btn" onclick="generateMnemonic('binary')">Generate from Binary</button>
                </div>

                <div id="generator-result" class="result-area" style="display: none;"></div>
            </div>

            <!-- Validator Tool -->
            <div class="tool-card">
                <h2>‚úÖ Mnemonic Validator</h2>
                
                <div class="form-group">
                    <label for="validate-input">Mnemonic Phrase:</label>
                    <textarea id="validate-input" class="form-control" placeholder="Enter your mnemonic phrase here..." rows="3"></textarea>
                </div>
                
                <button class="btn" onclick="validateMnemonic()">Validate Mnemonic</button>
                <button class="btn btn-secondary" onclick="showDetailedValidation()">Detailed Analysis</button>
                
                <div id="validator-result" class="result-area" style="display: none;"></div>
            </div>

            <!-- Bit Pattern Analyzer -->
            <div class="tool-card">
                <h2>üîç Bit Pattern Analyzer</h2>
                
                <div class="tabs">
                    <div class="tab active" onclick="switchTab('bit', 'pattern')">Find Pattern</div>
                    <div class="tab" onclick="switchTab('bit', 'word')">Analyze Word</div>
                </div>

                <div id="bit-pattern" class="tab-content active">
                    <div class="form-group">
                        <label for="pattern-input">4-bit Pattern (0-15):</label>
                        <input type="text" id="pattern-input" class="form-control" placeholder="e.g., 1010, A, 10">
                    </div>
                    <button class="btn" onclick="analyzeBitPattern()">Find Words</button>
                </div>

                <div id="bit-word" class="tab-content">
                    <div class="form-group">
                        <label for="word-input">BIP39 Word:</label>
                        <input type="text" id="word-input" class="form-control" placeholder="e.g., abandon">
                    </div>
                    <button class="btn" onclick="analyzeWord()">Analyze Word</button>
                </div>

                <div id="analyzer-result" class="result-area" style="display: none;"></div>
            </div>
        </div>
    </div>

    <script>
        // BIP39 wordlist will be loaded here
        let bip39Words = [];

        // Load BIP39 wordlist
        async function loadWordlist() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/bitcoin/bips/master/bip-0039/english.txt');
                const text = await response.text();
                bip39Words = text.trim().split('\n').map(word => word.trim());
                console.log(`Loaded ${bip39Words.length} BIP39 words`);
            } catch (error) {
                console.error('Failed to load BIP39 wordlist:', error);
                showResult('generator-result', 'Error: Failed to load BIP39 wordlist. Please check your internet connection.', 'error');
            }
        }

        // Utility functions
        function showResult(elementId, content, type = '') {
            const element = document.getElementById(elementId);
            element.style.display = 'block';
            element.innerHTML = type ? `<div class="status ${type}">${content}</div>` : content;
        }

        function switchTab(tool, tabName) {
            // Hide all tab contents for this tool
            const contents = document.querySelectorAll(`[id^="${tool}-"]`);
            contents.forEach(content => {
                if (content.classList.contains('tab-content')) {
                    content.classList.remove('active');
                }
            });

            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));

            // Show selected tab content
            document.getElementById(`${tool}-${tabName}`).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
        }

        // Cryptographic functions
        async function sha256(data) {
            const encoder = new TextEncoder();
            const dataBuffer = encoder.encode(data);
            const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
            return new Uint8Array(hashBuffer);
        }

        async function sha256Bytes(bytes) {
            const hashBuffer = await crypto.subtle.digest('SHA-256', bytes);
            return new Uint8Array(hashBuffer);
        }

        function generateSecureRandom(bits) {
            const bytes = Math.ceil(bits / 8);
            const randomBytes = new Uint8Array(bytes);
            crypto.getRandomValues(randomBytes);
            
            // Convert to bigint
            let result = 0n;
            for (let i = 0; i < randomBytes.length; i++) {
                result = (result << 8n) | BigInt(randomBytes[i]);
            }
            
            // Mask to exact bit length
            const mask = (1n << BigInt(bits)) - 1n;
            return result & mask;
        }

        async function calculateChecksum(entropyBits, entropyBitLength) {
            const entropyByteLength = entropyBitLength / 8;
            const entropyBytes = new Uint8Array(entropyByteLength);
            
            // Convert bigint to bytes
            let temp = entropyBits;
            for (let i = entropyByteLength - 1; i >= 0; i--) {
                entropyBytes[i] = Number(temp & 0xFFn);
                temp = temp >> 8n;
            }
            
            const hash = await sha256Bytes(entropyBytes);
            const checksumBits = entropyBitLength / 32;
            
            let checksum = 0;
            for (let i = 0; i < checksumBits; i++) {
                const byteIndex = Math.floor(i / 8);
                const bitIndex = 7 - (i % 8);
                const bit = (hash[byteIndex] >> bitIndex) & 1;
                checksum = (checksum << 1) | bit;
            }
            
            return checksum;
        }

        async function entropyToMnemonic(entropyBits, entropyBitLength = 128) {
            if (bip39Words.length === 0) {
                throw new Error('BIP39 wordlist not loaded');
            }

            const checksum = await calculateChecksum(entropyBits, entropyBitLength);
            const checksumBits = entropyBitLength / 32;
            
            const combinedBits = (entropyBits << BigInt(checksumBits)) | BigInt(checksum);
            const totalBits = entropyBitLength + checksumBits;
            const wordCount = totalBits / 11;
            
            const words = [];
            for (let i = 0; i < wordCount; i++) {
                const startBit = totalBits - 11 - (i * 11);
                const wordIndex = Number((combinedBits >> BigInt(startBit)) & 0x7FFn);
                words.push(bip39Words[wordIndex]);
            }
            
            return words;
        }

        // Generator functions
        async function generateMnemonic(type) {
            if (bip39Words.length === 0) {
                showResult('generator-result', 'Loading wordlist...', '');
                await loadWordlist();
            }

            try {
                let entropyBits;
                let entropyDisplay;

                if (type === 'random') {
                    entropyBits = generateSecureRandom(128);
                    entropyDisplay = `Random entropy generated: ${entropyBits.toString(16).padStart(32, '0')}`;
                } else if (type === 'hex') {
                    const hexInput = document.getElementById('hex-input').value.trim().replace(/^0x/, '');
                    if (!/^[0-9a-fA-F]{32}$/.test(hexInput)) {
                        throw new Error('Please enter exactly 32 hexadecimal characters');
                    }
                    entropyBits = BigInt('0x' + hexInput);
                    entropyDisplay = `Hex entropy: ${hexInput}`;
                } else if (type === 'binary') {
                    const binaryInput = document.getElementById('binary-input').value.trim().replace(/\s/g, '');
                    if (!/^[01]{128}$/.test(binaryInput)) {
                        throw new Error('Please enter exactly 128 binary digits (0s and 1s)');
                    }
                    entropyBits = BigInt('0b' + binaryInput);
                    entropyDisplay = `Binary entropy: ${binaryInput}`;
                }

                const words = await entropyToMnemonic(entropyBits);
                const checksum = await calculateChecksum(entropyBits, 128);
                
                const result = `
<div class="mnemonic-display">
    <strong>Generated Mnemonic:</strong>
    <div class="mnemonic-words">
        ${words.map((word, i) => `<div class="mnemonic-word">${i + 1}. ${word}</div>`).join('')}
    </div>
</div>

<strong>Details:</strong>
${entropyDisplay}
Entropy (binary): ${entropyBits.toString(2).padStart(128, '0')}
Checksum: ${checksum.toString(2).padStart(4, '0')} (${checksum})

<strong>Complete mnemonic phrase:</strong>
${words.join(' ')}`;

                showResult('generator-result', result);
            } catch (error) {
                showResult('generator-result', error.message, 'error');
            }
        }

        // Validator functions
        async function validateMnemonic() {
            if (bip39Words.length === 0) {
                await loadWordlist();
            }

            const mnemonic = document.getElementById('validate-input').value.trim().toLowerCase();
            const words = mnemonic.split(/\s+/);
            
            try {
                const validation = await performValidation(words);
                displayValidationResult(validation);
            } catch (error) {
                showResult('validator-result', error.message, 'error');
            }
        }

        async function performValidation(words) {
            const validLengths = {12: 128, 15: 160, 18: 192, 21: 224, 24: 256};
            const wordCount = words.length;
            
            const result = {
                wordCount,
                words,
                validations: {}
            };

            // Validate word count
            if (!(wordCount in validLengths)) {
                result.validations.wordCount = {
                    valid: false,
                    message: `Invalid word count: ${wordCount}. Valid counts are: ${Object.keys(validLengths).join(', ')}`
                };
                result.valid = false;
                return result;
            }

            const entropyBitLength = validLengths[wordCount];
            result.validations.wordCount = {
                valid: true,
                message: `Valid word count for ${entropyBitLength}-bit entropy`
            };

            // Validate words in wordlist
            const invalidWords = [];
            words.forEach((word, index) => {
                if (!bip39Words.includes(word)) {
                    invalidWords.push(`Position ${index + 1}: '${word}'`);
                }
            });

            if (invalidWords.length > 0) {
                result.validations.wordsInWordlist = {
                    valid: false,
                    message: `Invalid words found:\n${invalidWords.join('\n')}`
                };
                result.valid = false;
                return result;
            }

            result.validations.wordsInWordlist = {
                valid: true,
                message: 'All words are in the BIP39 wordlist'
            };

            // Validate checksum
            const wordIndices = words.map(word => bip39Words.indexOf(word));
            let combinedBits = 0n;
            
            for (const index of wordIndices) {
                combinedBits = (combinedBits << 11n) | BigInt(index);
            }

            const checksumBitLength = entropyBitLength / 32;
            const entropyBits = combinedBits >> BigInt(checksumBitLength);
            const actualChecksum = Number(combinedBits & ((1n << BigInt(checksumBitLength)) - 1n));
            
            const expectedChecksum = await calculateChecksum(entropyBits, entropyBitLength);

            if (actualChecksum === expectedChecksum) {
                result.validations.checksum = {
                    valid: true,
                    message: `Checksum valid (${expectedChecksum.toString(2).padStart(checksumBitLength, '0')})`
                };
                result.valid = true;
            } else {
                result.validations.checksum = {
                    valid: false,
                    message: `Checksum invalid (expected: ${expectedChecksum.toString(2).padStart(checksumBitLength, '0')}, actual: ${actualChecksum.toString(2).padStart(checksumBitLength, '0')})`
                };
                result.valid = false;
            }

            result.entropyBits = entropyBitLength;
            result.entropy = entropyBits;
            result.checksum = actualChecksum;

            return result;
        }

        function displayValidationResult(validation) {
            const status = validation.valid ? '‚úÖ VALID' : '‚ùå INVALID';
            const statusClass = validation.valid ? 'success' : 'error';
            
            let result = `
<div class="status ${statusClass}">
    <strong>Mnemonic Status: ${status}</strong><br>
    Word Count: ${validation.wordCount}
</div>

<strong>Validation Details:</strong>`;

            for (const [checkName, checkResult] of Object.entries(validation.validations)) {
                const checkStatus = checkResult.valid ? '‚úÖ PASS' : '‚ùå FAIL';
                result += `\n${checkName.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}: ${checkStatus}`;
                result += `\n  ${checkResult.message}`;
            }

            if (validation.valid && validation.entropy) {
                result += `\n\n<strong>Entropy Information:</strong>`;
                result += `\nEntropy (hex): ${validation.entropy.toString(16).padStart(validation.entropyBits / 4, '0')}`;
                result += `\nEntropy (binary): ${validation.entropy.toString(2).padStart(validation.entropyBits, '0')}`;
                result += `\nChecksum: ${validation.checksum.toString(2).padStart(validation.entropyBits / 32, '0')}`;
            }

            showResult('validator-result', result);
        }

        // Bit pattern analyzer functions
        async function analyzeBitPattern() {
            if (bip39Words.length === 0) {
                await loadWordlist();
            }

            const patternInput = document.getElementById('pattern-input').value.trim();
            
            try {
                let pattern;
                
                if (/^[01]+$/.test(patternInput) && patternInput.length <= 4) {
                    pattern = parseInt(patternInput, 2);
                } else if (/^[0-9a-fA-F]$/.test(patternInput)) {
                    pattern = parseInt(patternInput, 16);
                } else {
                    pattern = parseInt(patternInput, 10);
                }

                if (pattern < 0 || pattern > 15) {
                    throw new Error('Pattern must be between 0 and 15');
                }

                const matchingWords = [];
                bip39Words.forEach((word, index) => {
                    if ((index & 0xF) === pattern) {
                        matchingWords.push({index, word});
                    }
                });

                const patternBinary = pattern.toString(2).padStart(4, '0');
                const patternHex = pattern.toString(16).toUpperCase();

                let result = `
<strong>Pattern Analysis: ${patternBinary} (hex: ${patternHex}, decimal: ${pattern})</strong>
Total words found: ${matchingWords.length}
Percentage: ${(matchingWords.length / 2048 * 100).toFixed(1)}%

<strong>First 20 matching words:</strong>`;

                matchingWords.slice(0, 20).forEach(({index, word}) => {
                    const binary11 = index.toString(2).padStart(11, '0');
                    const hex3 = index.toString(16).padStart(3, '0');
                    result += `\n${index.toString().padStart(4)} | ${binary11} | ${hex3} | ${word}`;
                });

                if (matchingWords.length > 20) {
                    result += `\n... and ${matchingWords.length - 20} more words`;
                }

                result += `\n\n<strong>Pattern Formula:</strong>`;
                result += `\nIndices: ${pattern}, ${pattern + 16}, ${pattern + 32}, ${pattern + 48}, ...`;
                result += `\nFormula: ${pattern} + (16 √ó n) where n = 0, 1, 2, 3, ...`;

                showResult('analyzer-result', result);
            } catch (error) {
                showResult('analyzer-result', error.message, 'error');
            }
        }

        async function analyzeWord() {
            if (bip39Words.length === 0) {
                await loadWordlist();
            }

            const word = document.getElementById('word-input').value.trim().toLowerCase();
            
            if (!word) {
                showResult('analyzer-result', 'Please enter a word to analyze', 'error');
                return;
            }

            const index = bip39Words.indexOf(word);
            
            if (index === -1) {
                showResult('analyzer-result', `'${word}' is not in the BIP39 wordlist`, 'error');
                return;
            }

            const binary11 = index.toString(2).padStart(11, '0');
            const last4Bits = index & 0xF;
            const last4Binary = last4Bits.toString(2).padStart(4, '0');
            const hex = index.toString(16).toUpperCase();

            // Find other words with same last 4 bits
            const samePatternWords = bip39Words
                .map((w, i) => ({word: w, index: i}))
                .filter(({index: i, word: w}) => (i & 0xF) === last4Bits && w !== word)
                .slice(0, 10);

            let result = `
<strong>Word Analysis: '${word}'</strong>
Index: ${index}
Full binary (11-bit): ${binary11}
Hexadecimal: ${hex}
Last 4 bits: ${last4Binary} (decimal: ${last4Bits}, hex: ${last4Bits.toString(16).toUpperCase()})

<strong>Other words with same last 4 bits pattern (${last4Binary}):</strong>`;

            samePatternWords.forEach(({word: w, index: i}) => {
                result += `\n${w} (index: ${i})`;
            });

            if (samePatternWords.length === 10) {
                const totalSamePattern = bip39Words.filter((w, i) => (i & 0xF) === last4Bits).length;
                result += `\n... and ${totalSamePattern - 11} more words with this pattern`;
            }

            showResult('analyzer-result', result);
        }

        async function showDetailedValidation() {
            if (bip39Words.length === 0) {
                await loadWordlist();
            }

            const mnemonic = document.getElementById('validate-input').value.trim().toLowerCase();
            const words = mnemonic.split(/\s+/);
            
            try {
                const validation = await performValidation(words);
                
                let result = displayValidationResult(validation);
                
                if (validation.valid) {
                    const wordIndices = words.map(word => bip39Words.indexOf(word));
                    
                    result = document.getElementById('validator-result').innerHTML;
                    result += `\n\n<strong>Word Breakdown:</strong>`;
                    
                    words.forEach((word, i) => {
                        const index = wordIndices[i];
                        const binary = index.toString(2).padStart(11, '0');
                        result += `\n${(i + 1).toString().padStart(2)}. ${word.padEnd(12)} (index: ${index.toString().padStart(4)}, binary: ${binary})`;
                    });
                }
                
                showResult('validator-result', result);
            } catch (error) {
                showResult('validator-result', error.message, 'error');
            }
        }

        // Initialize the app
        window.addEventListener('DOMContentLoaded', () => {
            loadWordlist();
        });
    </script>
</body>
</html>